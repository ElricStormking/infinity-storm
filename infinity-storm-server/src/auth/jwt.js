/**
 * JWT Utilities for Game Server Authentication
 * 
 * Portal-first architecture: Validates tokens generated by the web portal
 * Handles token verification, session management, and token refresh
 */

const jwt = require('jsonwebtoken');
const crypto = require('crypto');
const { getRedisClient } = require('../config/redis');

class JWTAuth {
    constructor() {
        // JWT secrets from environment
        this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || 'default-access-secret';
        this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 'default-refresh-secret';
        
        // Token expiration times
        this.accessTokenExpiry = process.env.JWT_ACCESS_EXPIRY || '30m';
        this.refreshTokenExpiry = process.env.JWT_REFRESH_EXPIRY || '7d';
        
        // Redis key prefixes
        this.sessionPrefix = 'game:session:';
        this.refreshTokenPrefix = 'game:refresh:';
        this.blacklistPrefix = 'game:blacklist:';
        
        // Session timeout (30 minutes in seconds)
        this.sessionTimeout = 30 * 60;
    }

    /**
     * Verify access token and return decoded payload
     * @param {string} token - JWT access token
     * @returns {Object} Decoded token payload
     * @throws {Error} If token is invalid or expired
     */
    verifyAccessToken(token) {
        try {
            return jwt.verify(token, this.accessTokenSecret);
        } catch (error) {
            if (error.name === 'TokenExpiredError') {
                throw new Error('Access token expired');
            }
            if (error.name === 'JsonWebTokenError') {
                throw new Error('Invalid access token');
            }
            throw new Error(`Token verification failed: ${error.message}`);
        }
    }

    /**
     * Verify refresh token and return decoded payload
     * @param {string} token - JWT refresh token
     * @returns {Object} Decoded token payload
     * @throws {Error} If token is invalid or expired
     */
    verifyRefreshToken(token) {
        try {
            return jwt.verify(token, this.refreshTokenSecret);
        } catch (error) {
            if (error.name === 'TokenExpiredError') {
                throw new Error('Refresh token expired');
            }
            if (error.name === 'JsonWebTokenError') {
                throw new Error('Invalid refresh token');
            }
            throw new Error(`Refresh token verification failed: ${error.message}`);
        }
    }

    /**
     * Generate new access token (for portal use)
     * @param {Object} payload - Token payload
     * @returns {string} JWT access token
     */
    generateAccessToken(payload) {
        return jwt.sign(payload, this.accessTokenSecret, {
            expiresIn: this.accessTokenExpiry,
            issuer: 'infinity-storm-portal',
            audience: 'infinity-storm-game'
        });
    }

    /**
     * Generate new refresh token (for portal use)
     * @param {Object} payload - Token payload
     * @returns {string} JWT refresh token
     */
    generateRefreshToken(payload) {
        return jwt.sign(payload, this.refreshTokenSecret, {
            expiresIn: this.refreshTokenExpiry,
            issuer: 'infinity-storm-portal',
            audience: 'infinity-storm-game'
        });
    }

    /**
     * Generate token hash for storage
     * @param {string} token - JWT token
     * @returns {string} SHA-256 hash of token
     */
    generateTokenHash(token) {
        return crypto.createHash('sha256').update(token).digest('hex');
    }

    /**
     * Store session in Redis with automatic expiry
     * @param {string} playerId - Player ID
     * @param {string} accessToken - Access token
     * @param {Object} sessionData - Additional session data
     * @returns {Promise<void>}
     */
    async storeSession(playerId, accessToken, sessionData = {}) {
        const redis = getRedisClient();
        const sessionKey = `${this.sessionPrefix}${playerId}`;
        const tokenHash = this.generateTokenHash(accessToken);
        
        // Session data with token hash and metadata
        const session = {
            token_hash: tokenHash,
            player_id: playerId,
            created_at: new Date().toISOString(),
            last_activity: new Date().toISOString(),
            ip_address: sessionData.ip_address,
            user_agent: sessionData.user_agent,
            expires_at: new Date(Date.now() + (this.sessionTimeout * 1000)).toISOString(),
            ...sessionData
        };
        
        // Store session with automatic expiry
        await redis.setex(sessionKey, this.sessionTimeout, JSON.stringify(session));
        
        // Also store token hash for reverse lookup
        await redis.setex(
            `${this.sessionPrefix}token:${tokenHash}`,
            this.sessionTimeout,
            playerId
        );
    }

    /**
     * Get session from Redis by player ID
     * @param {string} playerId - Player ID
     * @returns {Promise<Object|null>} Session data or null
     */
    async getSession(playerId) {
        const redis = getRedisClient();
        const sessionKey = `${this.sessionPrefix}${playerId}`;
        
        const sessionData = await redis.get(sessionKey);
        if (!sessionData) {
            return null;
        }
        
        return JSON.parse(sessionData);
    }

    /**
     * Get session by token hash
     * @param {string} tokenHash - Token hash
     * @returns {Promise<Object|null>} Session data or null
     */
    async getSessionByTokenHash(tokenHash) {
        const redis = getRedisClient();
        const tokenKey = `${this.sessionPrefix}token:${tokenHash}`;
        
        const playerId = await redis.get(tokenKey);
        if (!playerId) {
            return null;
        }
        
        return await this.getSession(playerId);
    }

    /**
     * Update session activity timestamp
     * @param {string} playerId - Player ID
     * @returns {Promise<boolean>} True if session was updated
     */
    async updateActivity(playerId) {
        const redis = getRedisClient();
        const sessionKey = `${this.sessionPrefix}${playerId}`;
        
        const sessionData = await redis.get(sessionKey);
        if (!sessionData) {
            return false;
        }
        
        const session = JSON.parse(sessionData);
        session.last_activity = new Date().toISOString();
        
        // Refresh expiry time
        await redis.setex(sessionKey, this.sessionTimeout, JSON.stringify(session));
        
        // Also refresh token hash lookup
        await redis.setex(
            `${this.sessionPrefix}token:${session.token_hash}`,
            this.sessionTimeout,
            playerId
        );
        
        return true;
    }

    /**
     * Invalidate session (logout)
     * @param {string} playerId - Player ID
     * @returns {Promise<boolean>} True if session was invalidated
     */
    async invalidateSession(playerId) {
        const redis = getRedisClient();
        const sessionKey = `${this.sessionPrefix}${playerId}`;
        
        // Get session to find token hash
        const sessionData = await redis.get(sessionKey);
        if (sessionData) {
            const session = JSON.parse(sessionData);
            // Remove token hash lookup
            await redis.del(`${this.sessionPrefix}token:${session.token_hash}`);
            
            // Blacklist the token
            await this.blacklistToken(session.token_hash);
        }
        
        // Remove session
        const result = await redis.del(sessionKey);
        return result > 0;
    }

    /**
     * Blacklist a token to prevent reuse
     * @param {string} tokenHash - Token hash to blacklist
     * @returns {Promise<void>}
     */
    async blacklistToken(tokenHash) {
        const redis = getRedisClient();
        const blacklistKey = `${this.blacklistPrefix}${tokenHash}`;
        
        // Blacklist for the remaining token lifetime
        await redis.setex(blacklistKey, this.sessionTimeout, 'blacklisted');
    }

    /**
     * Check if token is blacklisted
     * @param {string} tokenHash - Token hash to check
     * @returns {Promise<boolean>} True if token is blacklisted
     */
    async isTokenBlacklisted(tokenHash) {
        const redis = getRedisClient();
        const blacklistKey = `${this.blacklistPrefix}${tokenHash}`;
        
        const result = await redis.get(blacklistKey);
        return result !== null;
    }

    /**
     * Validate access token with comprehensive checks
     * @param {string} token - JWT access token
     * @returns {Promise<Object>} Validation result with user data
     */
    async validateAccessToken(token) {
        try {
            // 1. Verify JWT signature and expiry
            const decoded = this.verifyAccessToken(token);
            
            // 2. Generate token hash for Redis checks
            const tokenHash = this.generateTokenHash(token);
            
            // 3. Check if token is blacklisted
            const isBlacklisted = await this.isTokenBlacklisted(tokenHash);
            if (isBlacklisted) {
                throw new Error('Token has been invalidated');
            }
            
            // 4. Get session from Redis
            const session = await this.getSessionByTokenHash(tokenHash);
            if (!session) {
                throw new Error('Session not found or expired');
            }
            
            // 5. Check session expiry
            const now = new Date();
            const expiresAt = new Date(session.expires_at);
            if (now >= expiresAt) {
                // Clean up expired session
                await this.invalidateSession(decoded.player_id);
                throw new Error('Session expired');
            }
            
            // 6. Update activity (refresh session)
            await this.updateActivity(decoded.player_id);
            
            // 7. Return validated user data
            return {
                valid: true,
                player_id: decoded.player_id,
                username: decoded.username,
                email: decoded.email,
                is_admin: decoded.is_admin || false,
                is_demo: decoded.is_demo || false,
                session: session
            };
            
        } catch (error) {
            return {
                valid: false,
                error: error.message
            };
        }
    }

    /**
     * Check if session needs refresh (less than 5 minutes remaining)
     * @param {string} playerId - Player ID
     * @returns {Promise<boolean>} True if session needs refresh
     */
    async needsRefresh(playerId) {
        const session = await this.getSession(playerId);
        if (!session) {
            return false;
        }
        
        const now = new Date();
        const expiresAt = new Date(session.expires_at);
        const timeRemaining = expiresAt - now;
        
        // Refresh if less than 5 minutes remaining
        return timeRemaining < (5 * 60 * 1000);
    }

    /**
     * Refresh session with new expiry time
     * @param {string} playerId - Player ID
     * @param {string} newAccessToken - New access token (optional)
     * @returns {Promise<boolean>} True if session was refreshed
     */
    async refreshSession(playerId, newAccessToken = null) {
        const session = await this.getSession(playerId);
        if (!session) {
            return false;
        }
        
        // Update session data
        session.last_activity = new Date().toISOString();
        session.expires_at = new Date(Date.now() + (this.sessionTimeout * 1000)).toISOString();
        
        // If new token provided, update token hash
        if (newAccessToken) {
            // Remove old token hash lookup
            await getRedisClient().del(`${this.sessionPrefix}token:${session.token_hash}`);
            
            // Update with new token hash
            session.token_hash = this.generateTokenHash(newAccessToken);
            
            // Store new token hash lookup
            await getRedisClient().setex(
                `${this.sessionPrefix}token:${session.token_hash}`,
                this.sessionTimeout,
                playerId
            );
        }
        
        // Store updated session
        const redis = getRedisClient();
        const sessionKey = `${this.sessionPrefix}${playerId}`;
        await redis.setex(sessionKey, this.sessionTimeout, JSON.stringify(session));
        
        return true;
    }

    /**
     * Get all active sessions (admin function)
     * @returns {Promise<Array>} Array of active sessions
     */
    async getActiveSessions() {
        const redis = getRedisClient();
        const pattern = `${this.sessionPrefix}*`;
        
        const keys = await redis.keys(pattern);
        const sessions = [];
        
        for (const key of keys) {
            // Skip token hash lookup keys
            if (key.includes(':token:')) {
                continue;
            }
            
            const sessionData = await redis.get(key);
            if (sessionData) {
                const session = JSON.parse(sessionData);
                sessions.push({
                    ...session,
                    key: key.replace(this.sessionPrefix, '')
                });
            }
        }
        
        return sessions;
    }

    /**
     * Clean up expired sessions (maintenance function)
     * @returns {Promise<number>} Number of sessions cleaned up
     */
    async cleanupExpiredSessions() {
        // Redis automatically removes expired keys, but we can force cleanup
        // of any remaining expired sessions
        const sessions = await this.getActiveSessions();
        const now = new Date();
        let cleanedUp = 0;
        
        for (const session of sessions) {
            const expiresAt = new Date(session.expires_at);
            if (now >= expiresAt) {
                await this.invalidateSession(session.player_id);
                cleanedUp++;
            }
        }
        
        return cleanedUp;
    }
}

module.exports = new JWTAuth();