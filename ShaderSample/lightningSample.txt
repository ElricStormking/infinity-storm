//reusing https://shadertoy.com/view/WdGXWG

#define hash(p) ( 2.* fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) - 1. )

float noise( vec2 p )                                // Perlin base noise ( grandient noise )
{
    vec2 i = floor( p ),
         f = fract( p ),
	     u = f*f*(3.-2.*f);

#define P(x,y) dot( hash( i + vec2(x,y) ), f - vec2(x,y) )
    return mix( mix( P(0,0), P(1,0), u.x),
                mix( P(0,1), P(1,1), u.x), u.y);
}

float perlin( vec2 p )                               // Perlin noise ( fractal noise )
{	
    float v  = 0.,s = 1.;
    for( int i=0; i++ < 7; s /= 2., p*=2. )
        v += s* noise( p );
    return v;
}

// -----------------------------------------------
#define rot(a) mat2(cos(a + vec4(0,11,33,0) ) )

void mainImage( out vec4 O, vec2 u )
{
    vec2 R = iResolution.xy,
         U = 2.* ( u+u -R ) / R.y;
         
    O = T(u) * vec4(.87,.8,.9,1);                    // reprint violet-fading prev frame.

    U *= rot( 6.28*hash(vec2(floor(iTime*4.))).x );  // change direction every 1/4th second
    
    //      glow             noise changing more often with distance to center.
    O += .01 / (abs( U.y - perlin(vec2(U.x, iFrame*int(1.+abs(U.x))/4)) * (.5+.3*U.x) ))
             * smoothstep(-.1,0.,U.x);               // draw only one side
}

